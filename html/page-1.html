<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Single-thread</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="wrapper">
        <h2>Single-thread</h2>
        <p>JS выполняет одно задание в единицу времени.</p>
        <p>Очередь заданий гарантирует последовательность выполнения поступивших задач</p>
        <p>Цикл событий - процесс внутри JS, управляет формированием очереди</p>
        <p>Цикл событий выполняет задачи последовательно - от первой задачи в очереди к последней такой задаче</p>
        <!-- контекст выполнения -->
        <details>
            <pre>
Вызов функции:
	- область видимости   // доступ к переменым
	- this                // ссылка на объект, вызывающий функцию
	- контекст выполнения // this + ОВ + аргументы функции
	
Код в JavaScript может быть одного из следующих типов:
	
   - eval-код — код, выполняющийся внутри функции eval();
   - код функции — код, выполняющийся в теле функции;
   - глобальный код — код, не выполняющийся в рамках какой-либо функции.

	
Новый контекст выполнения добавляется 
	в верхнюю часть стека выполнения
	после выполнения - удаляется
	

-Однопоточность — JavaScript работает в однопоточном режиме, 
    т.е. только одна операция может быть выполнена 
    в определенный момент времени.
-Синхронное выполнение кода — код выполняется синхронно, 
    т.е. следующая операция не выполняется до завершения предыдущей.
-Один глобальный контекст выполнения.
-Бесконечное количество контекстов выполнения функции.
-Каждый вызов функции создает новый контекст выполнения, 
    даже если функция рекурсивно вызывает сама себя.

Создание контекста выполнения происходит в два этапа: 
    - этап создания (когда функция только вызвана, 
                    но код внутри нее еще не выполняется) 
    - этап выполнения.
	
На этапе создания интерпретатор сначала создает объект переменных 
(также называемый объект активации), 
который состоит из всех 
	-переменных, 
	-объявлений функций и 
	-аргументов, определенных внутри контекста выполнения. 
	-Затем инициализируется область видимости, 
	-и в последнюю очередь определяется значение переменной this. 	
	
На этапе выполнения внутренним переменным присваивается значение, 
                    код интерпретируется и выполняется.	


            </pre>
        </details>
        <h4>Событие</h4>
        <p>Событие - это добавление функции в очередь на выполнение на основе асинхронного события.
            Как правило - на действие пользователя (click, focus, blur и т.п.)
        </p>
        <details><pre><code>
    elem.addEventListener('click', callback)
    function callback (evt) {consolle.log(evt.target)}
        </code></pre></details>
        <p>Две сложности связаны с событийным асинхронным программированнием.</p>
        <ol>
            <li>Сложность обработки заданной цепочки событий (click -&gt; keypress -&gt; ...)</li>
            <li>Необходимость следить за своевременным добавлением и удаленим обработчиков событий</li>
        </ol>
        <h4>Обратные вызовы</h4>
        <p>Обратный вызов - это использование функции как параметра для другой функции</p>
        <details><pre><code>
    setTimeout(callback, 1000);
    function callback () { 
        console.log('я могу быть параметром')
    }
        </code></pre></details>
        <p>Построение заданных цепочек реализуется относительно просто - 
            вложением в функцию-параметр следующей callback функции. </p>
        <p>Вложение callback функций может расти. 
            Внешне это выглядит как смещение кода прогаммы вправо при каждом 
            новом callback. 
            Неприятно, когда такое длинный текст не помещается в окно редактора.
            Можно callback функции выносить, оставляя лишь вызов.
            Но тогда придется все равно перемещаться по экрану в поисках очередной функции.
            
        </p>
        <p>Но основная сложности возникает при необходимости обмена и сравнения данных
            между независимыми асинхронными функциями.
            Такая ситуация требует внешенего <b>объекта для обмена данными</b>. 
            Код получается <i>сильно связанным</i> - изменение чего-то одного (объекта или какой-то функции)
            потребует переписать все зависимые функции и объект.
            Все вместе эти негативные факторы называются callback hell (ад из callback-ов).
        </p>
        <h4>Пример до использования Promise.race([])</h4>
        <p>Обратите внимание на использование объекта асинхронными функциями</p>
        <details>
                <p data-height="265" data-theme-id="0" data-slug-hash="zLgQeV" data-default-tab="css,result" data-user="Gorbulin" data-pen-title="Before promise race" class="codepen">See the Pen <a href="https://codepen.io/Gorbulin/pen/zLgQeV/">Before promise race</a> by Gennadiy (<a href="https://codepen.io/Gorbulin">@Gorbulin</a>) on <a href="https://codepen.io">CodePen</a>.</p>
                <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        </details>
        <h4>Пример до использования Promise.all([])</h4>
        <details>
                <p data-height="265" data-theme-id="0" data-slug-hash="mjNYxr" data-default-tab="js,result" data-user="Gorbulin" data-pen-title="before promise all" class="codepen">See the Pen <a href="https://codepen.io/Gorbulin/pen/mjNYxr/">before promise all</a> by Gennadiy (<a href="https://codepen.io/Gorbulin">@Gorbulin</a>) on <a href="https://codepen.io">CodePen</a>.</p>
                <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        </details>
    </div>
   <script src="../js/app.js"></script>
</body>
</html>