<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Single-thread</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="wrapper">
        <h2>Single-thread</h2>
        <p>JS выполняет одно задание в единицу времени.</p>
        <p>Очередь заданий гарантирует последовательность выполнения поступивших задач</p>
        <p>Цикл событий - процесс внутри JS, управляет формированием очереди</p>
        <p>Цикл событий выполняет задачи последовательно - от первой задачи в очереди к последней такой задаче</p>
        <!-- контекст выполнения -->
        <details>
            <pre>
Вызов функции:
	- область видимости   // доступ к переменым
	- this                // ссылка на объект, вызывающий функцию
	- контекст выполнения // this + ОВ + аргументы функции
	
Код в JavaScript может быть одного из следующих типов:
	
   - eval-код — код, выполняющийся внутри функции eval();
   - код функции — код, выполняющийся в теле функции;
   - глобальный код — код, не выполняющийся в рамках какой-либо функции.

	
Новый контекст выполнения добавляется 
	в верхнюю часть стека выполнения
	после выполнения - удаляется
	

-Однопоточность — JavaScript работает в однопоточном режиме, 
    т.е. только одна операция может быть выполнена 
    в определенный момент времени.
-Синхронное выполнение кода — код выполняется синхронно, 
    т.е. следующая операция не выполняется до завершения предыдущей.
-Один глобальный контекст выполнения.
-Бесконечное количество контекстов выполнения функции.
-Каждый вызов функции создает новый контекст выполнения, 
    даже если функция рекурсивно вызывает сама себя.

Создание контекста выполнения происходит в два этапа: 
    - этап создания (когда функция только вызвана, 
                    но код внутри нее еще не выполняется) 
    - этап выполнения.
	
На этапе создания интерпретатор сначала создает объект переменных 
(также называемый объект активации), 
который состоит из всех 
	-переменных, 
	-объявлений функций и 
	-аргументов, определенных внутри контекста выполнения. 
	-Затем инициализируется область видимости, 
	-и в последнюю очередь определяется значение переменной this. 	
	
На этапе выполнения внутренним переменным присваивается значение, 
                    код интерпретируется и выполняется.	


            </pre>
        </details>
        <h4>Событие</h4>
        <p>Событие - это добавление функции в очередь на выполнение на основе асинхронного события.
            Как правило - на действие пользователя (click, focus, blur и т.п.)
        </p>
        <p>Две сложности связаны с событийным асинхронным программированнием.</p>
        <ol>
            <li>Сложность построения заданных цепочек событий.</li>
            <li>Обработчики событий должны быть установлены до возможности реализации событий</li>
        </ol>
        <h4>Обратные вызовы</h4>
        <p>Обратный вызов - это использование функции как параметра для другой функции</p>
        <p>Построение заданных цепочек реализуется относительно просто - 
            вложением в функцию-параметр следующей callback функции. </p>
        <p>Вложение callback функций может расти, что приводит к сложности отладки и тестирования.
            Эта проблема носит специальное название - CallBack Hell
        </p>
        <p>Сложности возникают при запуске нескольких асинхронных операций и попытке применения результат только одной
            из операций. Например только той, что получила определенный результат. 
            Сложность в том, что данные внутри одного из CallBack Hell должны сопоставляться с данными
            других CallBack Hell. 
            Это требует внешенего объекта для обмена данными. 
            Код получается  сильно связанным - изменение объекта требует изменения кода во всех
            асинхронных цепочках. И наоборот - изменение в одной из цепочек может потребовать
            переписать объект, а значит и все остальные цепочки.
        </p>
        <details>
            <pre><code>
                    <p data-height="265" data-theme-id="0" data-slug-hash="rJLBPM" data-default-tab="css,result" data-user="Gorbulin" data-pen-title="async hell full " class="codepen">See the Pen <a href="https://codepen.io/Gorbulin/pen/rJLBPM/">async hell full </a> by Gennadiy (<a href="https://codepen.io/Gorbulin">@Gorbulin</a>) on <a href="https://codepen.io">CodePen</a>.</p>
                    <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
            </code></pre>
        </details>
    </div>
   <script src="../js/app.js"></script>
</body>
</html>